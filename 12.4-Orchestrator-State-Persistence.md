# 12.4 üíæ Persist√™ncia de Estado do `orchestrator.py`

**Objetivo**: Garantir a idempot√™ncia e a resili√™ncia do `orchestrator.py` mesmo ap√≥s rein√≠cios do container ou da aplica√ß√£o, prevenindo o reprocessamento desnecess√°rio de v√≠deos.

**Status Atual no Checklist**: `| Persist√™ncia de Estado do orchestrator.py | üìù A√ß√£o Requerida |`

---

## 1. Vis√£o Geral e Justificativa

O `orchestrator.py` √© o cora√ß√£o do pipeline de processamento de v√≠deo, monitorando novos arquivos e disparando as etapas de `scan_video`, `summarize_scene`, e `logline_generator`. Atualmente, ele "evita reprocessamento usando set interno de nomes". Se este "set interno" for mantido apenas na mem√≥ria, ele ser√° perdido sempre que o script ou seu container reiniciar. Isso levaria ao reprocessamento de todos os v√≠deos j√° presentes na pasta de entrada, causando desperd√≠cio de recursos, inconsist√™ncias potenciais e sobrecarga no sistema.

A persist√™ncia do estado dos arquivos processados √© crucial para a robustez e efici√™ncia do orquestrador.

## 2. Estrat√©gias de Persist√™ncia de Estado

Existem v√°rias maneiras de persistir o estado dos v√≠deos processados. A escolha depende da complexidade, do volume de arquivos e dos requisitos de performance.

### 2.1. Arquivo de Log/Estado Simples (Recomendado para In√≠cio)

*   **Descri√ß√£o**: Manter um arquivo de texto simples onde cada linha cont√©m um identificador √∫nico do v√≠deo processado (e.g., hash SHA256 do arquivo de v√≠deo ou o nome do arquivo, se forem garantidamente √∫nicos e imut√°veis ap√≥s o processamento inicial).
*   **Implementa√ß√£o**:
    *   Ao iniciar, `orchestrator.py` l√™ este arquivo e carrega os identificadores em um set na mem√≥ria.
    *   Antes de processar um novo v√≠deo, verifica se seu identificador j√° est√° no set.
    *   Ap√≥s processar um v√≠deo com sucesso, adiciona seu identificador ao set em mem√≥ria e anexa-o ao arquivo de estado no disco.
*   **Vantagens**:
    *   Simples de implementar.
    *   Baixa sobrecarga.
    *   Leg√≠vel por humanos para depura√ß√£o.
*   **Desvantagens**:
    *   Para um volume muito grande de arquivos, a leitura inicial e a busca no set em mem√≥ria podem consumir mais mem√≥ria.
    *   Opera√ß√µes de escrita no arquivo devem ser at√¥micas ou pelo menos seguras contra corrup√ß√£o parcial em caso de falha abrupta (e.g., escrever em um arquivo tempor√°rio e depois renomear).
*   **Local do Arquivo**: Deve ser em um volume persistente montado no container do orquestrador (e.g., dentro de `${VIDEO_STORAGE_ROOT}/orchestrator_state/processed_videos.log`).

### 2.2. Banco de Dados Leve (e.g., SQLite)

*   **Descri√ß√£o**: Usar um banco de dados SQLite para armazenar os identificadores dos v√≠deos processados e, opcionalmente, metadados adicionais (e.g., timestamp do processamento, status da √∫ltima etapa).
*   **Implementa√ß√£o**:
    *   `orchestrator.py` se conecta ao arquivo do banco de dados SQLite (localizado em um volume persistente).
    *   Antes de processar um v√≠deo, consulta o banco para verificar se o identificador existe.
    *   Ap√≥s o processamento, insere um novo registro no banco.
*   **Vantagens**:
    *   Mais robusto para grandes volumes de dados.
    *   Permite consultas mais complexas (e.g., "quais v√≠deos foram processados na √∫ltima semana?").
    *   Transa√ß√µes ACID garantem consist√™ncia.
*   **Desvantagens**:
    *   Adiciona uma depend√™ncia (biblioteca SQLite).
    *   Ligeiramente mais complexo de implementar do que um arquivo de texto.
*   **Local do Arquivo**: `${VIDEO_STORAGE_ROOT}/orchestrator_state/orchestrator_db.sqlite`.

### 2.3. Movimenta√ß√£o de Arquivos Processados

*   **Descri√ß√£o**: Em vez de rastrear o estado, o orquestrador move os arquivos de v√≠deo de uma pasta de entrada (`input/pending/`) para uma pasta de "processados" (`input/completed/`) ap√≥s o sucesso. O orquestrador apenas monitora a pasta `input/pending/`.
*   **Implementa√ß√£o**:
    *   O orquestrador lista arquivos apenas em `input/pending/`.
    *   Ap√≥s todas as etapas de processamento para um v√≠deo serem conclu√≠das com sucesso, o arquivo original √© movido para `input/completed/`.
    *   Se uma etapa falhar, o v√≠deo pode ser movido para `input/failed/` ou deixado em `pending/` para nova tentativa (com l√≥gica de retry).
*   **Vantagens**:
    *   Mecanismo de estado muito simples e visual.
    *   N√£o requer arquivos de estado ou bancos de dados adicionais para o rastreamento b√°sico.
*   **Desvantagens**:
    *   A opera√ß√£o de mover arquivos (especialmente grandes) entre diferentes sistemas de arquivos (se `${VIDEO_STORAGE_ROOT}` for complexo) pode ser lenta ou n√£o at√¥mica. Dentro do mesmo sistema de arquivos, geralmente √© r√°pida.
    *   Requer uma estrutura de diret√≥rios mais granular.
    *   Menos flex√≠vel se for necess√°rio reprocessar um v√≠deo (teria que ser movido de volta para `pending/`).

## 3. Implementa√ß√£o Detalhada (Usando Arquivo de Log/Estado Simples)

Esta √© geralmente a abordagem mais equilibrada para come√ßar.

### 3.1. Modifica√ß√µes em `scripts/orchestrator.py`

```python
import os
import hashlib
import time
import logging
from pathlib import Path

# Configura√ß√£o de Logging (assumindo que j√° existe)
# logging.basicConfig(...)

# Caminho para o arquivo de estado (deve vir de uma vari√°vel de ambiente ou configura√ß√£o)
# Exemplo: /opt/vv-video-ai-system/orchestrator_data/processed_videos.txt
STATE_FILE_PATH = Path(os.getenv("ORCHESTRATOR_STATE_FILE", "/opt/vv-video-ai-system/orchestrator_data/processed_videos.txt"))
INPUT_VIDEO_DIR = Path(os.getenv("INPUT_VIDEO_DIR", "/opt/vv-video-ai-system/input")) # Diret√≥rio a ser monitorado
PROCESSED_SET = set()

# Fun√ß√µes auxiliares (do vv-core ou locais)
def compute_sha256(file_path: Path) -> str:
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def load_processed_state():
    """Carrega o estado dos v√≠deos processados do arquivo."""
    STATE_FILE_PATH.parent.mkdir(parents=True, exist_ok=True) # Garante que o diret√≥rio existe
    if STATE_FILE_PATH.exists():
        with open(STATE_FILE_PATH, "r") as f:
            for line in f:
                PROCESSED_SET.add(line.strip())
    logging.info(f"Carregados {len(PROCESSED_SET)} identificadores de v√≠deos processados do estado.")

def save_processed_state(video_identifier: str):
    """Salva o identificador de um v√≠deo processado no arquivo de estado."""
    with open(STATE_FILE_PATH, "a") as f:
        f.write(video_identifier + "\n")
    PROCESSED_SET.add(video_identifier)
    logging.info(f"V√≠deo {video_identifier} adicionado ao estado de processados.")

def call_scan_video(video_path: Path):
    """Placeholder para chamar o container scan_video."""
    logging.info(f"Chamando scan_video para {video_path.name}...")
    # L√≥gica para executar docker-compose run scene_scanner ... ou similar
    # Exemplo: subprocess.run(["docker-compose", "run", "--rm", "scene_scanner", "python", "scan_video.py", str(video_path)], check=True)
    time.sleep(5) # Simula processamento
    logging.info(f"scan_video para {video_path.name} conclu√≠do.")
    return True # Retorna True em sucesso

def call_summarize_scene(video_path: Path, analytic_json_path: Path):
    """Placeholder para chamar o container scene_summarizer."""
    logging.info(f"Chamando summarize_scene para {video_path.name}...")
    # L√≥gica para executar docker-compose run scene_summarizer ...
    time.sleep(5) # Simula processamento
    logging.info(f"summarize_scene para {video_path.name} conclu√≠do.")
    return True # Retorna True em sucesso

def call_logline_generator(video_path: Path, summary_json_path: Path):
    """Placeholder para chamar o container logline_writer."""
    logging.info(f"Chamando logline_generator para {video_path.name}...")
    # L√≥gica para executar docker-compose run logline_writer ...
    time.sleep(3) # Simula processamento
    logging.info(f"logline_generator para {video_path.name} conclu√≠do.")
    return True # Retorna True em sucesso


def process_video_pipeline(video_path: Path) -> bool:
    """Executa o pipeline completo para um v√≠deo."""
    try:
        # Aqui, voc√™ decidiria qual identificador usar.
        # O nome do arquivo pode n√£o ser √∫nico se os arquivos puderem ser substitu√≠dos com o mesmo nome.
        # O hash do conte√∫do √© mais robusto.
        video_identifier = compute_sha256(video_path)
        # Ou, se os nomes s√£o √∫nicos e est√°veis: video_identifier = video_path.name

        if video_identifier in PROCESSED_SET:
            logging.info(f"V√≠deo {video_path.name} (ID: {video_identifier}) j√° processado. Pulando.")
            return True # Considerado sucesso pois j√° foi feito

        logging.info(f"Iniciando processamento para {video_path.name} (ID: {video_identifier}).")

        # Etapa 1: scan_video
        # Supondo que scan_video cria um <video_name>.analytic.json em um diret√≥rio espec√≠fico
        analytic_output_path = Path("/opt/vv-video-ai-system/analytic") / f"{video_path.stem}.analytic.json" # Exemplo
        if not call_scan_video(video_path):
            logging.error(f"Falha em scan_video para {video_path.name}.")
            # Considerar mover para 'corrupted' ou l√≥gica de retry aqui
            return False

        # Etapa 2: summarize_scene
        # Supondo que summarize_scene cria um <video_name>.summary.json
        summary_output_path = Path("/opt/vv-video-ai-system/summaries") / f"{video_path.stem}.summary.json" # Exemplo
        if not call_summarize_scene(video_path, analytic_output_path):
            logging.error(f"Falha em summarize_scene para {video_path.name}.")
            return False

        # Etapa 3: logline_generator
        if not call_logline_generator(video_path, summary_output_path):
            logging.error(f"Falha em logline_generator para {video_path.name}.")
            return False

        # Todas as etapas conclu√≠das com sucesso
        save_processed_state(video_identifier)
        logging.info(f"Processamento de {video_path.name} (ID: {video_identifier}) conclu√≠do com sucesso.")
        
        # Opcional: Mover o v√≠deo original para um diret√≥rio de 'processados com sucesso'
        # processed_video_dir = INPUT_VIDEO_DIR.parent / "completed"
        # processed_video_dir.mkdir(parents=True, exist_ok=True)
        # video_path.rename(processed_video_dir / video_path.name)
        # logging.info(f"V√≠deo {video_path.name} movido para {processed_video_dir}.")

        return True

    except Exception as e:
        logging.exception(f"Erro inesperado ao processar {video_path.name}: {e}")
        return False


def main_loop():
    """Loop principal do orquestrador."""
    load_processed_state()
    orchestrator_interval = int(os.getenv("ORCHESTRATOR_INTERVAL", "300")) # Segundos

    while True:
        logging.info("Orquestrador verificando novos v√≠deos...")
        new_videos_found = 0
        for video_file in INPUT_VIDEO_DIR.glob("*.mp4"): # Ou outros formatos
            if video_file.is_file():
                # Uma verifica√ß√£o adicional: garantir que o arquivo n√£o est√° sendo escrito no momento.
                # Comparar tamanho do arquivo em intervalos curtos ou verificar a idade de modifica√ß√£o.
                # Para simplificar, vamos assumir que arquivos em INPUT_VIDEO_DIR est√£o completos.
                
                # Usar o hash do conte√∫do como identificador √© mais robusto
                try:
                    current_video_identifier = compute_sha256(video_file)
                    if current_video_identifier not in PROCESSED_SET:
                        logging.info(f"Novo v√≠deo encontrado: {video_file.name} (ID: {current_video_identifier})")
                        process_video_pipeline(video_file) # Processa e atualiza o estado internamente
                        new_videos_found += 1
                    # else:
                    #     logging.debug(f"V√≠deo {video_file.name} (ID: {current_video_identifier}) j√° consta como processado no set em mem√≥ria.")

                except Exception as e:
                    logging.exception(f"N√£o foi poss√≠vel obter identificador ou verificar {video_file.name}: {e}")
            
        if new_videos_found == 0:
            logging.info("Nenhum v√≠deo novo encontrado nesta verifica√ß√£o.")
        
        logging.info(f"Orquestrador aguardando {orchestrator_interval} segundos para a pr√≥xima verifica√ß√£o.")
        time.sleep(orchestrator_interval)

if __name__ == "__main__":
    # Configurar logging adequadamente
    log_format = '%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_format)
    # Adicionar handler para arquivo se necess√°rio, e.g., logs/orchestrator.log

    # Garante que o diret√≥rio de estado existe
    STATE_FILE_PATH.parent.mkdir(parents=True, exist_ok=True)

    main_loop()