# 12.5 üîÑ Gerenciamento Avan√ßado de Imagens com Watchtower e CI/CD

**Objetivo**: Otimizar o processo de atualiza√ß√£o das imagens Docker do `VV-Video-AI-System`, especialmente as constru√≠das localmente, utilizando um registro de container privado e um pipeline de Integra√ß√£o Cont√≠nua/Entrega Cont√≠nua (CI/CD).

**Status Atual no Checklist**: `| Gerenciamento Avan√ßado de Imagens (CI/CD) | üí° Sugest√£o |`

---

## 1. Vis√£o Geral e Justificativa

Atualmente, o `VV-Video-AI-System` utiliza `watchtower` para atualiza√ß√µes autom√°ticas, o que √© excelente para imagens p√∫blicas ou de registros onde novas vers√µes s√£o publicadas. No entanto, para as imagens internas do projeto (e.g., `agent_dvr`, `scan_video`, `scene_summarizer`, etc.), que s√£o constru√≠das a partir do c√≥digo fonte no reposit√≥rio, o `watchtower` por si s√≥ n√£o aciona reconstru√ß√µes quando o c√≥digo fonte muda. O "rebuild semanal" mencionado no blueprint original √© uma solu√ß√£o paliativa, mas pode n√£o ser √°gil o suficiente e pode reconstruir imagens desnecessariamente.

A implementa√ß√£o de um pipeline de CI/CD, juntamente com um registro de container privado, oferece uma abordagem mais robusta, eficiente e automatizada para gerenciar o ciclo de vida dessas imagens customizadas.

## 2. Componentes da Solu√ß√£o

1.  **Reposit√≥rio Git (Existente)**: GitHub, GitLab, Bitbucket, etc., onde o c√≥digo fonte do `VV-Video-AI-System` reside.
2.  **Servi√ßo de CI/CD**:
    *   **Op√ß√µes Populares**: GitHub Actions (altamente integrado se o c√≥digo est√° no GitHub), GitLab CI/CD (integrado se no GitLab), Jenkins, CircleCI, Travis CI.
    *   **Fun√ß√£o**: Automatizar a constru√ß√£o, teste e publica√ß√£o de imagens Docker quando houver altera√ß√µes no c√≥digo fonte.
3.  **Registro de Container Privado**:
    *   **Op√ß√µes Populares**: Docker Hub (oferece reposit√≥rios privados), GitHub Container Registry (GHCR), GitLab Container Registry, Amazon ECR, Google Artifact Registry, Azure Container Registry, Harbor (self-hosted).
    *   **Fun√ß√£o**: Armazenar as imagens Docker constru√≠das e versionadas pelo pipeline de CI/CD.
4.  **Watchtower (Configura√ß√£o Ajustada)**:
    *   **Fun√ß√£o**: Continuar√° monitorando e atualizando os containers em execu√ß√£o, mas agora ele ser√° configurado para observar o registro privado para novas vers√µes das imagens internas.

## 3. Fluxo de Trabalho Detalhado

1.  **Desenvolvimento**: Um desenvolvedor faz altera√ß√µes no c√≥digo de um dos servi√ßos (e.g., `scan_video/scan_video.py` ou seu `Dockerfile`).
2.  **Commit e Push**: As altera√ß√µes s√£o enviadas (push) para o reposit√≥rio Git (e.g., para a branch `main` ou ap√≥s um merge de uma feature branch).
3.  **Gatilho do CI/CD**: O push para a branch designada aciona o pipeline de CI/CD.
4.  **Pipeline de CI/CD Executa**:
    *   **Checkout do C√≥digo**: O pipeline obt√©m a vers√£o mais recente do c√≥digo.
    *   **(Opcional, mas Recomendado) Executar Testes**: Testes unit√°rios, de integra√ß√£o para o servi√ßo modificado. Se os testes falharem, o pipeline para.
    *   **Construir Imagem Docker**:
        *   O pipeline constr√≥i a imagem Docker para o servi√ßo modificado (e.g., `docker build -t <nome_registro>/<usuario_ou_org>/vv-scene-scanner:latest -t <nome_registro>/<usuario_ou_org>/vv-scene-scanner:<git_sha_ou_tag> ./scan_video/`).
        *   √â crucial versionar as imagens. Usar o `latest` √© comum, mas tamb√©m uma tag mais espec√≠fica como o hash do commit Git (`<git_sha>`), uma tag sem√¢ntica (`v1.2.3`), ou um n√∫mero de build √© fundamental para rastreabilidade e rollbacks.
    *   **Login no Registro Privado**: O pipeline se autentica no registro de container privado.
    *   **Push da Imagem Docker**: A imagem constru√≠da e taggeada √© enviada (push) para o registro privado.
5.  **Watchtower Detecta Atualiza√ß√£o**:
    *   `watchtower` (rodando no servidor de produ√ß√£o/edge) est√° configurado para monitorar o registro privado para as imagens internas do `VV-Video-AI-System`.
    *   Quando detecta que uma nova vers√£o de uma imagem (e.g., `<nome_registro>/<usuario_ou_org>/vv-scene-scanner:latest`) foi publicada, ele:
        *   Baixa (pull) a nova imagem.
        *   Para o container existente que usa a imagem antiga.
        *   Inicia um novo container com a nova imagem, mantendo a configura√ß√£o (volumes, portas, vari√°veis de ambiente) definida no `docker-compose.yml`.
6.  **Sistema Atualizado**: O servi√ßo agora est√° rodando com a vers√£o mais recente do c√≥digo.

## 4. Implementa√ß√£o Detalhada

### 4.1. Escolher e Configurar um Registro de Container Privado

*   **Exemplo com GitHub Container Registry (GHCR)**:
    *   Se o seu reposit√≥rio est√° no GitHub, o GHCR √© uma op√ß√£o natural e bem integrada.
    *   As imagens s√£o vinculadas ao seu usu√°rio ou organiza√ß√£o: `ghcr.io/<SEU_USUARIO_OU_ORG>/<NOME_IMAGEM>:<TAG>`.
    *   A autentica√ß√£o geralmente usa um Personal Access Token (PAT) com escopo `write:packages` (para push do CI) e `read:packages` (para pull do Watchtower e `docker-compose`).

### 4.2. Configurar o Pipeline de CI/CD

*   **Exemplo com GitHub Actions**:
    Criar um arquivo de workflow em `.github/workflows/docker-publish.yml`:

    ```yaml name=docker-publish.yml
    name: Docker Publish CI

    on:
      push:
        branches: [ "main" ] # Aciona na branch main
        paths: # Aciona apenas se houver mudan√ßas em diret√≥rios de servi√ßos ou Dockerfiles
          - 'agent_dvr/**'
          - 'scan_video/**'
          - 'summarize_scene/**'
          - 'logline_generator/**'
          - 'tv_scheduler/**'
          - 'tv_ui/**'
          - 'tv_mirror_ui/**'
          - 'vv_ingest/**'
          - 'llm_monitor_service/**' # Se implementado
          # Adicionar outros diret√≥rios de servi√ßo conforme necess√°rio
          # Ou acionar para qualquer Dockerfile
          # - '**/Dockerfile'
      workflow_dispatch: # Permite acionamento manual

    jobs:
      build_and_publish:
        runs-on: ubuntu-latest
        permissions:
          contents: read
          packages: write # Necess√°rio para push para GHCR

        strategy:
          matrix: # Matriz para construir m√∫ltiplas imagens se necess√°rio
            service:
              - name: agent_dvr
                path: ./agent_dvr
              - name: scene_scanner
                path: ./scan_video
              - name: scene_summarizer
                path: ./summarize_scene
              # Adicionar todos os seus servi√ßos que t√™m Dockerfiles aqui
              # - name: my_other_service
              #   path: ./my_other_service_dir

        steps:
          - name: Checkout repository
            uses: actions/checkout@v4

          - name: Set up Docker Buildx
            uses: docker/setup-buildx-action@v3

          - name: Log in to GitHub Container Registry
            uses: docker/login-action@v3
            with:
              registry: ghcr.io
              username: ${{ github.actor }}
              password: ${{ secrets.GITHUB_TOKEN }} # Token gerado automaticamente pelo GitHub Actions

          - name: Get current date for tagging
            id: date
            run: echo "date=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT

          - name: Build and push Docker image for ${{ matrix.service.name }}
            if: steps.checkout.outputs.paths_filter_${{ matrix.service.name }} == 'true' # Verifica se o path do servi√ßo foi alterado (requer configura√ß√£o adicional de filtro de paths ou l√≥gica de script)
                                                                                       # Simplifica√ß√£o: por agora, vamos assumir que sempre constru√≠mos se o workflow √© acionado por um path relevante.
                                                                                       # Uma abordagem mais granular verificaria qual 'path' espec√≠fico mudou.
            uses: docker/build-push-action@v5
            with:
              context: ${{ matrix.service.path }}
              file: ${{ matrix.service.path }}/Dockerfile
              push: true
              tags: |
                ghcr.io/${{ github.repository_owner }}/vv-${{ matrix.service.name }}:latest
                ghcr.io/${{ github.repository_owner }}/vv-${{ matrix.service.name }}:${{ github.sha }}
                ghcr.io/${{ github.repository_owner }}/vv-${{ matrix.service.name }}:build-${{ steps.date.outputs.date }}
              # platforms: linux/amd64,linux/arm64 # Para multi-arch builds se necess√°rio
              cache-from: type=gha
              cache-to: type=gha,mode=max

    # Para uma verifica√ß√£o mais precisa de quais servi√ßos reconstruir, voc√™ pode:
    # 1. Usar uma action que detecta mudan√ßas em diret√≥rios espec√≠ficos para cada job da matriz.
    # 2. Ter workflows separados por servi√ßo (mais verboso).
    # 3. Um script no step de "Build and push" que decide se constr√≥i baseado nas mudan√ßas.
    # Exemplo de filtro de path (requer mais configura√ß√£o):
    # paths-filter:
    #   agent_dvr:
    #     - 'agent_dvr/**'
    #   scene_scanner:
    #     - 'scan_video/**'
    ```
    **Notas sobre o Workflow**:
    *   `github.repository_owner` √© usado para garantir que funcione para usu√°rios ou organiza√ß√µes.
    *   As imagens s√£o taggeadas com `latest`, o `github.sha` (hash do commit), e um timestamp de build.
    *   `secrets.GITHUB_TOKEN` √© um token com escopo autom√°tico fornecido pelo GitHub Actions.
    *   A l√≥gica de `if` para reconstruir apenas servi√ßos alterados pode ser aprimorada. Uma forma simples √© ter um job separado por servi√ßo e usar `paths` no `on:` trigger para cada job.

### 4.3. Atualizar `docker-compose.yml`

Modifique o `docker-compose.yml` para usar as imagens do seu registro privado.

```yaml
version: '3.8'

services:
  agent_dvr:
    image: ghcr.io/<SEU_USUARIO_OU_ORG>/vv-agent_dvr:latest # Alterado
    container_name: agent_dvr
    # ... resto da configura√ß√£o
  
  scene_scanner:
    image: ghcr.io/<SEU_USUARIO_OU_ORG>/vv-scene_scanner:latest # Alterado
    container_name: scene_scanner
    # ... resto da configura√ß√£o

  # ... para todos os outros servi√ßos constru√≠dos customizadamente

  watchtower:
    image: containrrr/watchtower:latest
    container_name: watchtower
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      # - $HOME/.docker/config.json:/config.json # Para autentica√ß√£o no registro privado
    environment:
      # WATCHTOWER_POLL_INTERVAL: 300 # Segundos (default 300 = 5 minutos)
      WATCHTOWER_CLEANUP: "true" # Remove imagens antigas
      WATCHTOWER_INCLUDE_STOPPED: "true" # Considera containers parados para atualiza√ß√£o
      # WATCHTOWER_DEBUG: "true"
      # Credenciais para o registro privado (se o config.json montado n√£o for suficiente ou preferir env vars)
      REPO_USER: "<SEU_USUARIO_OU_PAT_PARA_GHCR>" # Usu√°rio para o registro
      REPO_PASS: "${GHCR_TOKEN_FOR_WATCHTOWER}"  # Token de acesso pessoal com escopo read:packages
                                                 # Armazenado como vari√°vel de ambiente no host ou em um .env
    command: >
      --interval 300
      vv-agent_dvr 
      vv-scene_scanner
      # Adicione os nomes dos *containers* (n√£o imagens) que voc√™ quer que o Watchtower monitore.
      # Watchtower usar√° o nome da imagem do container para verificar atualiza√ß√µes.
      # Se n√£o listar nenhum, ele monitora todos. √â melhor ser expl√≠cito.

# ...