Alright, let's move on to `12.10 üìä M√©tricas Detalhadas para Monitoramento de Recursos (Prometheus/Grafana)`. This section is also marked as "üí° Sugest√£o" and aims to enrich the observability of the system.

Here's the current content from `VV-Video-AI-System-Master-Blueprint-v2.2.md` for section 12.10:

```markdown
### 12.10 üìä M√©tricas Detalhadas para Monitoramento de Recursos (Prometheus/Grafana)

*   **Objetivo**: Enriquecer o conjunto de m√©tricas para uma observabilidade mais profunda.
*   **Contexto**: "M√©tricas compat√≠veis com Prometheus/Grafana" j√° planejado.
*   **M√©tricas Adicionais Sugeridas**:
    *   **Pipeline de V√≠deo**:
        *   N√∫mero de v√≠deos na fila de processamento (aguardando `scan_video.py`).
        *   Tempo m√©dio de processamento por est√°gio (`scan_video`, `summarize_scene`, `logline_generator`).
        *   Taxa de erro por est√°gio do pipeline.
        *   N√∫mero de arquivos em `corrupted/`.
    *   **Recursos de IA**:
        *   Tempo de infer√™ncia do modelo BitNet.
        *   Taxa de sucesso/falha das infer√™ncias.
        *   Uso de CPU/GPU pelo container `scene_summarizer`.
    *   **Armazenamento**:
        *   Espa√ßo em disco utilizado/livre em `${VIDEO_STORAGE_ROOT}` e seus subdiret√≥rios.
        *   Taxa de crescimento do armazenamento.
    *   **Rede**:
        *   Lat√™ncia e taxa de erro na comunica√ß√£o com `DVR_IP`.
    *   **`tv_scheduler.py`**:
        *   N√∫mero de playlists geradas.
        *   Tempo para gerar playlists.
*   **Impacto Esperado**: Vis√£o detalhada da performance e gargalos do sistema, permitindo otimiza√ß√µes proativas.
```

This is a good list of suggested metrics. We can expand this by:

1.  **Detailing how these metrics would be exposed** (e.g., Prometheus client libraries in Python scripts, Node Exporter, cAdvisor).
2.  **Suggesting specific Prometheus metric types** (Counter, Gauge, Histogram, Summary).
3.  **Adding more granular metrics** for each category.
4.  **Considering metrics for other components** (e.g., NGINX, Orchestrator, `self_monitor.py`).
5.  **Thinking about how these metrics would translate into Grafana dashboards.**
6.  **Discussing the setup of Prometheus and Grafana** in the context of the `VV-Video-AI-System`.

Let's do a comprehensive expansion.

---

## 12.10 üìä M√©tricas Detalhadas e Estrat√©gia de Monitoramento (Prometheus/Grafana)

**Objetivo:** Implementar um sistema de monitoramento abrangente utilizando Prometheus e Grafana para coletar, visualizar e alertar sobre m√©tricas detalhadas de performance, sa√∫de e utiliza√ß√£o de recursos do `VV-Video-AI-System`, permitindo otimiza√ß√µes proativas e diagn√≥sticos aprofundados.

**Contexto:** O plano original menciona "M√©tricas compat√≠veis com Prometheus/Grafana". Esta se√ß√£o detalha as m√©tricas espec√≠ficas, a forma de exposi√ß√£o e a arquitetura de monitoramento.

---

### 1. Arquitetura de Monitoramento

*   **Prometheus Server:**
    *   Respons√°vel por "raspar" (scrape) m√©tricas dos endpoints expostos pelos servi√ßos e exporters.
    *   Armazena as m√©tricas como s√©ries temporais.
    *   Pode ser executado como um container Docker no mesmo host do `VV-Video-AI-System` ou em um servidor de monitoramento dedicado (prefer√≠vel para produ√ß√£o em maior escala).
    *   Configura√ß√£o (`prometheus.yml`): Define os alvos de scrape (jobs).
*   **Grafana:**
    *   Ferramenta de visualiza√ß√£o que consulta o Prometheus (e outras fontes de dados).
    *   Permite criar dashboards interativos para monitorar as m√©tricas coletadas.
    *   Pode ser executado como um container Docker.
*   **Exporters de M√©tricas:**
    *   **Aplica√ß√µes Python (nossos scripts/servi√ßos):** Utilizar a biblioteca cliente Prometheus para Python (`prometheus_client`) para expor m√©tricas customizadas via um endpoint HTTP (e.g., `/metrics` em cada servi√ßo relevante).
    *   **cAdvisor (Container Advisor):** Exporta m√©tricas de uso de recursos de containers Docker (CPU, mem√≥ria, rede, I/O). O Prometheus pode ser configurado para raspar o cAdvisor. Muitas vezes, o Docker daemon j√° exp√µe m√©tricas que o Prometheus pode consumir diretamente ou via um exporter.
    *   **Node Exporter:** Exporta m√©tricas do host do sistema operacional (CPU, mem√≥ria, disco, rede do host).
    *   **NGINX Exporter (opcional):** Se NGINX for usado (`12.1`), um exporter pode fornecer m√©tricas detalhadas do NGINX. (e.g., `nginx-prometheus-exporter`).
*   **Alertmanager (Opcional, mas recomendado):**
    *   Integrado com Prometheus para gerenciar alertas baseados em regras definidas no Prometheus.
    *   Lida com deduplica√ß√£o, agrupamento, silenciamento e roteamento de alertas para v√°rios canais (Slack, PagerDuty, email, etc., como definido em `12.9`).

---

### 2. M√©tricas Detalhadas por Componente/Categoria

#### 2.1. M√©tricas do Pipeline de V√≠deo (Expostas pelos scripts/servi√ßos relevantes)

*   **`orchestrator.py` / Geral do Pipeline:**
    *   `vv_videos_in_input_queue_total` (Gauge): N√∫mero de v√≠deos atualmente no diret√≥rio `input/` aguardando processamento.
    *   `vv_videos_processed_total` (Counter): Total de v√≠deos processados com sucesso pelo pipeline completo. Labels: `status="success"`, `status="failure"`.
    *   `vv_video_processing_duration_seconds` (Histogram/Summary): Dura√ß√£o do processamento de um v√≠deo atrav√©s de todo o pipeline. Labels: `video_filename` (cuidado com cardinalidade alta), `status`.
    *   `vv_files_in_corrupted_total` (Gauge): N√∫mero de arquivos atualmente no diret√≥rio `corrupted/`.
    *   `vv_pipeline_stage_active_processors` (Gauge): N√∫mero de "processadores" (e.g., inst√¢ncias de script/container) ativos para cada est√°gio. Labels: `stage="scan" | "summarize" | "logline"`. (√ötil se houver paralelismo).

*   **`scan_video.py` (Scene Scanner):**
    *   `vv_scan_video_processed_total` (Counter): Total de v√≠deos processados por `scan_video`. Labels: `status="success" | "failure"`.
    *   `vv_scan_video_duration_seconds` (Histogram/Summary): Dura√ß√£o do processamento de `scan_video`.
    *   `vv_scan_video_frames_scanned_total` (Counter): Total de frames analisados.
    *   `vv_scan_video_objects_detected_total` (Counter): Total de objetos detectados (pode ter label `object_type`).
    *   `vv_scan_video_faces_detected_total` (Counter): Total de faces detectadas.
    *   `vv_scan_video_schema_validation_errors_total` (Counter): Erros de valida√ß√£o do `analytic.schema.json`.

*   **`summarize_scene.py` (Scene Summarizer / BitNet):**
    *   `vv_summarize_scene_processed_total` (Counter): Total de an√°lises processadas. Labels: `status="success" | "failure"`.
    *   `vv_summarize_scene_duration_seconds` (Histogram/Summary): Dura√ß√£o da sumariza√ß√£o (incluindo I/O do modelo e infer√™ncia).
    *   `vv_summarize_scene_bitnet_inference_duration_seconds` (Histogram/Summary): Dura√ß√£o espec√≠fica da infer√™ncia do modelo BitNet.
    *   `vv_summarize_scene_model_loaded_info` (Gauge): Informa√ß√£o sobre o modelo carregado. Labels: `model_name`, `model_version`. (Valor 1 se carregado).
    *   `vv_summarize_scene_gpu_utilization_percent` (Gauge): (Se GPU for usada e a biblioteca permitir medi√ß√£o) Utiliza√ß√£o da GPU.
    *   `vv_summarize_scene_gpu_memory_used_bytes` (Gauge): (Se GPU for usada) Mem√≥ria GPU usada.
    *   `vv_summarize_scene_schema_validation_errors_total` (Counter): Erros de valida√ß√£o do `summary.schema.json`.

*   **`logline_generator.py` (Logline Writer):**
    *   `vv_logline_generated_total` (Counter): Total de LogLines geradas. Labels: `status="success" | "failure"`.
    *   `vv_logline_generation_duration_seconds` (Histogram/Summary): Dura√ß√£o da gera√ß√£o de LogLines.
    *   `vv_logline_hmac_errors_total` (Counter): Erros durante a assinatura HMAC.
    *   `vv_logline_schema_validation_errors_total` (Counter): Erros de valida√ß√£o do `logline.schema.json`.

#### 2.2. M√©tricas de Recursos do Sistema (via Node Exporter, cAdvisor)

*   **Host (Node Exporter):**
    *   `node_cpu_seconds_total` (Counter): Uso de CPU do host (por modo: user, system, idle, etc.).
    *   `node_memory_MemAvailable_bytes` (Gauge): Mem√≥ria dispon√≠vel no host.
    *   `node_memory_MemTotal_bytes` (Gauge): Mem√≥ria total no host.
    *   `node_filesystem_avail_bytes` (Gauge): Espa√ßo em disco dispon√≠vel por ponto de montagem (e.g., para `/`, `/opt/vv-video-ai-system`, `${VIDEO_STORAGE_ROOT}`). Labels: `mountpoint`, `fstype`.
    *   `node_filesystem_size_bytes` (Gauge): Tamanho total do disco por ponto de montagem.
    *   `node_disk_io_time_seconds_total` (Counter): Tempo gasto em I/O de disco.
    *   `node_network_receive_bytes_total` (Counter): Bytes de rede recebidos por interface.
    *   `node_network_transmit_bytes_total` (Counter): Bytes de rede transmitidos por interface.
    *   `node_load1`, `node_load5`, `node_load15` (Gauge): Load average do sistema.

*   **Containers (cAdvisor ou m√©tricas do Docker daemon):**
    *   `container_cpu_usage_seconds_total` (Counter): Uso de CPU por container. Labels: `container_name`, `id`.
    *   `container_memory_usage_bytes` (Gauge): Uso de mem√≥ria por container. Labels: `container_name`, `id`.
    *   `container_network_receive_bytes_total` (Counter): Bytes de rede recebidos por container.
    *   `container_network_transmit_bytes_total` (Counter): Bytes de rede transmitidos por container.
    *   `container_fs_reads_bytes_total`, `container_fs_writes_bytes_total` (Counter): I/O de disco por container.
    *   `container_restarts_total` (Counter): N√∫mero de rein√≠cios de um container. (Pode ser exposto por `self_monitor.py` tamb√©m).

#### 2.3. M√©tricas de Servi√ßos de Suporte

*   **`tv_scheduler.py` (Playlist Manager):**
    *   `vv_tv_scheduler_playlists_generated_total` (Counter): Total de playlists geradas. Labels: `tv_id` (e.g., tv1, tv2), `status="success" | "failure"`.
    *   `vv_tv_scheduler_generation_duration_seconds` (Histogram/Summary): Dura√ß√£o da gera√ß√£o de playlists. Labels: `tv_id`.
    *   `vv_tv_scheduler_loglines_processed_total` (Counter): N√∫mero de loglines lidas e processadas para gerar playlists.
    *   `vv_tv_scheduler_runs_total` (Counter): N√∫mero de vezes que o scheduler rodou.

*   **`agent_dvr` (Video Capture):**
    *   `vv_agent_dvr_connection_status` (Gauge): Status da conex√£o com o DVR (e.g., 1=conectado, 0=desconectado).
    *   `vv_agent_dvr_connection_errors_total` (Counter): Total de erros de conex√£o com o DVR.
    *   `vv_agent_dvr_frames_captured_total` (Counter): Total de frames capturados (se aplic√°vel e mensur√°vel).
    *   `vv_agent_dvr_video_segments_created_total` (Counter): Total de segmentos de v√≠deo salvos em `input/`.

*   **`self_monitor.py`:**
    *   `vv_self_monitor_container_restarts_triggered_total` (Counter): Total de rein√≠cios de container iniciados pelo `self_monitor`. Labels: `container_name`.
    *   `vv_self_monitor_unhealthy_services_detected_total` (Counter): Contagem de detec√ß√µes de servi√ßos n√£o saud√°veis.

*   **NGINX (via `nginx-prometheus-exporter` ou logs se `12.1` for implementado):**
    *   `nginx_http_requests_total` (Counter): Total de requisi√ß√µes HTTP. Labels: `status` (2xx, 4xx, 5xx), `method`, `path`.
    *   `nginx_http_request_duration_seconds` (Histogram): Lat√™ncia das requisi√ß√µes.
    *   `nginx_connections_active` (Gauge): Conex√µes ativas.

#### 2.4. M√©tricas de Scripts Auxiliares

*   **`cleanup_old_files.py`:**
    *   `vv_cleanup_files_deleted_total` (Counter): N√∫mero de arquivos deletados.
    *   `vv_cleanup_bytes_deleted_total` (Counter): Total de bytes deletados.
    *   `vv_cleanup_duration_seconds` (Histogram/Summary): Dura√ß√£o da execu√ß√£o do script.
    *   `vv_cleanup_runs_total` (Counter): Labels: `dry_run="true"|"false"`, `status="success"|"failure"`.

*   **`log_exporter.py`:**
    *   `vv_log_exporter_archives_created_total` (Counter): Total de arquivos de log exportados.
    *   `vv_log_exporter_duration_seconds` (Histogram/Summary): Dura√ß√£o da exporta√ß√£o.

---

### 3. Implementa√ß√£o da Exposi√ß√£o de M√©tricas

*   **Python Scripts/Services:**
    *   Adicionar `prometheus_client` ao `requirements.txt` ou `Dockerfile`.
    *   Em cada script que precisa expor m√©tricas (e.g., `scan_video.py` se rodar como um servi√ßo de longa dura√ß√£o, ou `orchestrator.py` que chama os outros, ou os pr√≥prios scripts se forem persistentes):
        ```python
        from prometheus_client import start_http_server, Counter, Gauge, Histogram
        import time
        import random

        # Definir m√©tricas (globalmente no script ou m√≥dulo)
        PROCESSED_COUNTER = Counter('vv_my_script_processed_items_total', 'Total items processed by my_script', ['status'])
        ITEM_GAUGE = Gauge('vv_my_script_items_in_queue', 'Items currently in queue for my_script')
        PROCESSING_HISTOGRAM = Histogram('vv_my_script_processing_duration_seconds', 'Duration of item processing')

        def process_item(item):
            start_time = time.time()
            try:
                # ... l√≥gica de processamento ...
                time.sleep(random.uniform(0.1, 0.5)) # Simular trabalho
                if random.random() < 0.1:
                    raise ValueError("Simulated processing error")
                PROCESSED_COUNTER.labels(status='success').inc()
            except Exception:
                PROCESSED_COUNTER.labels(status='failure').inc()
                raise
            finally:
                duration = time.time() - start_time
                PROCESSING_HISTOGRAM.observe(duration)

        if __name__ == '__main__':
            # Iniciar um servidor HTTP para expor m√©tricas na porta 8001 (ou outra porta n√£o utilizada)
            # Isso s√≥ faz sentido se o script for um servi√ßo de longa dura√ß√£o.
            # Para scripts de cron, usar Pushgateway ou agregar m√©tricas em um servi√ßo central.
            # start_http_server(8001) 
            
            # Se for um script de cron, pode-se usar um Pushgateway:
            # from prometheus_client import CollectorRegistry, Gauge, push_to_gateway
            # registry = CollectorRegistry()
            # g = Gauge('vv_cron_job_last_success_timestamp', 'Last time a cron job completed successfully', registry=registry)
            # g.set_to_current_time()
            # push_to_gateway('pushgateway.example.org:9091', job='my_cron_job', registry=registry)

            # Exemplo de uso das m√©tricas:
            ITEM_GAUGE.set(10) # 10 itens na fila
            for i in range(5):
                try:
                    process_item(f"item_{i}")
                    ITEM_GAUGE.dec()
                except ValueError:
                    ITEM_GAUGE.dec() # Item removido da fila mesmo se falhou
                    print(f"Failed to process item_{i}")
        ```
    *   **Para scripts de curta dura√ß√£o (cronjobs):** A melhor abordagem √© usar o [Prometheus Pushgateway](https://github.com/prometheus/pushgateway). O script envia suas m√©tricas para o Pushgateway ao final da execu√ß√£o, e o Prometheus raspa o Pushgateway.
    *   **Servi√ßos de longa dura√ß√£o (FastAPI, etc.):** Podem expor um endpoint `/metrics` diretamente.

*   **`docker-compose.yml` para Prometheus e Grafana (Exemplo):**
    ```yaml
    version: '3.8'
    services:
      # ... seus outros servi√ßos VV-AI ...

      prometheus:
        image: prom/prometheus:latest
        container_name: prometheus
        restart: unless-stopped
        volumes:
          - ./prometheus.yml:/etc/prometheus/prometheus.yml # Arquivo de configura√ß√£o do Prometheus
          - prometheus_data:/prometheus # Volume para dados do Prometheus
        ports:
          - "9090:9090"
        command:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
          - '--web.console.libraries=/usr/share/prometheus/console_libraries'
          - '--web.console.templates=/usr/share/prometheus/consoles'
          # --web.enable-lifecycle (para permitir recarga de config via API)

      grafana:
        image: grafana/grafana-oss:latest
        container_name: grafana
        restart: unless-stopped
        ports:
          - "3000:3000"
        volumes:
          - grafana_data:/var/lib/grafana
        # environment:
        #   - GF_SECURITY_ADMIN_PASSWORD=your_grafana_admin_password

      cadvisor: # Opcional, se n√£o usar m√©tricas nativas do Docker ou outro m√©todo
        image: gcr.io/cadvisor/cadvisor:latest
        container_name: cadvisor
        restart: unless-stopped
        ports:
          - "8080:8080" # Porta do cAdvisor
        volumes:
          - /:/rootfs:ro
          - /var/run:/var/run:rw
          - /sys:/sys:ro
          - /var/lib/docker/:/var/lib/docker:ro
        # depends_on: - ... outros servi√ßos, se precisar que eles iniciem antes

      node_exporter: # Opcional, se quiser m√©tricas do host dentro do compose (pode ser executado fora)
        image: prom/node-exporter:latest
        container_name: node_exporter
        restart: unless-stopped
        ports:
          - "9100:9100" # Porta do Node Exporter
        volumes:
          - /proc:/host/proc:ro
          - /sys:/host/sys:ro
          - /:/rootfs:ro
        command:
          - '--path.procfs=/host/proc'
          - '--path.sysfs=/host/sys'
          - '--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|host|etc)($$|/)'
      
      # pushgateway: # Se usar para scripts de cron
      #   image: prom/pushgateway:latest
      #   container_name: pushgateway
      #   restart: unless-stopped
      #   ports:
      #     - "9091:9091"

    volumes:
      prometheus_data:
      grafana_data:
    ```

*   **`prometheus.yml` (Exemplo B√°sico):**
    ```yaml name=prometheus.yml
    global:
      scrape_interval: 15s # Por padr√£o, raspar a cada 15 segundos

    scrape_configs:
      - job_name: 'prometheus' # Raspar o pr√≥prio Prometheus
        static_configs:
          - targets: ['localhost:9090']

      - job_name: 'cadvisor' # Se usar cAdvisor
        static_configs:
          - targets: ['cadvisor:8080']

      - job_name: 'node_exporter' # Se usar Node Exporter
        static_configs:
          - targets: ['node_exporter:9100']

      # - job_name: 'pushgateway' # Se usar Pushgateway
      #   static_configs:
      #     - targets: ['pushgateway:9091']
      #   honor_labels: true


      - job_name: 'vv_ai_scene_scanner' # Exemplo para um servi√ßo seu
        static_configs:
          - targets: ['scene_scanner:8001'] # Assumindo que scene_scanner exp√µe m√©tricas na porta 8001

      - job_name: 'vv_ai_orchestrator' # Exemplo
        static_configs:
          - targets: ['orchestrator_service_host_or_container:8002'] # Ajustar conforme necess√°rio
      
      # Adicionar jobs para cada servi√ßo VV-AI que exp√µe m√©tricas
    ```

---

### 4. Dashboards Grafana (Sugest√µes)

Criar dashboards espec√≠ficos para:

1.  **Vis√£o Geral do Sistema VV-AI:**
    *   KPIs chave: v√≠deos na fila, taxa de processamento, taxa de erro, espa√ßo em disco.
    *   Status dos containers.
    *   Alertas ativos (se integrado com Alertmanager).
2.  **Performance do Pipeline de V√≠deo:**
    *   Funil de processamento (entrada -> scan -> summarize -> logline).
    *   Tempos de processamento por est√°gio.
    *   Taxas de erro por est√°gio.
    *   Contagem de arquivos em `corrupted/`.
3.  **Performance do Modelo BitNet:**
    *   Tempos de infer√™ncia.
    *   Uso de CPU/GPU pelo `scene_summarizer`.
    *   Contagem de sucessos/falhas.
4.  **Recursos do Host e Containers:**
    *   Uso de CPU, mem√≥ria, disco, rede para o host e para cada container individualmente.
    *   Baseado em m√©tricas do Node Exporter e cAdvisor.
5.  **Sa√∫de do Armazenamento:**
    *   Uso de disco detalhado para `${VIDEO_STORAGE_ROOT}` e seus subdiret√≥rios.
    *   Taxa de crescimento, previs√£o de esgotamento.
6.  **Sa√∫de do `tv_scheduler` e `agent_dvr`:**
    *   M√©tricas espec√≠ficas desses componentes.

---

### 5. Impacto Esperado

*   **Visibilidade Profunda:** Entendimento detalhado da performance e sa√∫de de cada componente do sistema.
*   **Detec√ß√£o Proativa de Problemas:** Identificar gargalos, degrada√ß√£o de performance ou problemas de recursos antes que causem falhas maiores.
*   **Otimiza√ß√£o Baseada em Dados:** M√©tricas permitem identificar √°reas para otimiza√ß√£o de c√≥digo ou aloca√ß√£o de recursos.
*   **Diagn√≥stico R√°pido:** Dashboards e m√©tricas facilitam a investiga√ß√£o da causa raiz de incidentes.
*   **Planejamento de Capacidade:** Monitorar o crescimento de dados e uso de recursos ajuda a planejar futuras necessidades de infraestrutura.
*   **Melhoria Cont√≠nua:** Base para avaliar o impacto de mudan√ßas e novas funcionalidades.

---

This provides a much more detailed strategy for metrics and monitoring. Implementing this will significantly enhance the operational capabilities of the VV-Video-AI-System.
