# 12.1 üîê Implementa√ß√£o de Prote√ß√£o de Acesso (NGINX + JWT)

**Objetivo**: Concluir a tarefa pendente `Prote√ß√£o de acesso (NGINX + JWT)` para assegurar todos os endpoints e UIs expostos, provendo autentica√ß√£o e autoriza√ß√£o robustas.

---

## 1. Vis√£o Geral

Proteger o `VV-Video-AI-System` √© crucial, especialmente se qualquer parte dele for acess√≠vel via rede. Esta se√ß√£o detalha a implementa√ß√£o de NGINX como um reverse proxy para gerenciar o tr√°fego de entrada, aplicar SSL/TLS, e impor autentica√ß√£o baseada em JSON Web Tokens (JWT) para servi√ßos selecionados.

## 2. Tarefas Detalhadas

### 2.1. Definir Escopo de Prote√ß√£o

Identificar os servi√ßos que necessitam de prote√ß√£o. Nem todos os servi√ßos podem precisar de autentica√ß√£o JWT (e.g., m√©tricas internas para Prometheus podem ser protegidas por rede).

*   **Servi√ßos Exigindo Autentica√ß√£o (Exemplos):**
    *   `tv_ui/tv.html`: Acesso √† interface principal de visualiza√ß√£o.
    *   `tv_mirror_ui/tv_mirror.html`: Acesso √† interface de espelhamento.
    *   `/status` endpoint da FastAPI: Acesso ao status da aplica√ß√£o.
    *   Quaisquer APIs de controle ou configura√ß√£o que possam ser expostas.
*   **Servi√ßos com Acesso Restrito por Rede/IP (Exemplos):**
    *   Endpoints `/metrics` para Prometheus.
    *   Comunica√ß√£o interna entre containers (j√° gerenciada pela rede Docker).

### 2.2. Configurar NGINX como Reverse Proxy

NGINX atuar√° como o ponto de entrada para todas as requisi√ß√µes HTTP(S).

*   **Instala√ß√£o do NGINX**:
    ```bash
    sudo apt update
    sudo apt install nginx
    ```
*   **Configura√ß√£o B√°sica de Reverse Proxy**:
    Criar um arquivo de configura√ß√£o em `/etc/nginx/sites-available/vv-video-ai`:

    ```nginx name=vv-video-ai.nginx.conf
    server {
        listen 80;
        server_name your_domain.com www.your_domain.com; # Ou endere√ßo IP

        # Redirecionar HTTP para HTTPS
        location / {
            return 301 https://$host$request_uri;
        }
    }

    server {
        listen 443 ssl http2;
        server_name your_domain.com www.your_domain.com; # Ou endere√ßo IP

        # Configura√ß√µes SSL/TLS (Let's Encrypt recomendado)
        ssl_certificate /etc/letsencrypt/live/your_domain.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/your_domain.com/privkey.pem;
        include /etc/letsencrypt/options-ssl-nginx.conf;
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

        # Cabe√ßalhos de Seguran√ßa
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-Content-Type-Options "nosniff";
        add_header Referrer-Policy "strict-origin-when-cross-origin";
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self';"; # Ajustar conforme necess√°rio
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # Proxy para o servi√ßo tv_ui (exemplo)
        location /tv_curado/ {
            # Requer valida√ß√£o JWT (ver se√ß√£o 2.3)
            # auth_jwt "VV-Video-AI Realm"; # Se usando nginx-plus-module- ‡§¶‡§æ‡§Ç‡§§-jwt
            # auth_jwt_key_file /etc/nginx/jwt_keys/public_key.pem; # Chave p√∫blica para verificar assinatura

            proxy_pass http://localhost:8001/; # Assumindo que tv_ui roda na porta 8001
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Proxy para o endpoint /status da FastAPI (exemplo)
        location /status {
            # Requer valida√ß√£o JWT
            proxy_pass http://localhost:8000/status; # Assumindo que a FastAPI principal roda na 8000
            proxy_set_header Host $host;
            # ... outros headers de proxy
        }

        # Outros locations para outros servi√ßos...
    }
    ```
    Ativar o site: `sudo ln -s /etc/nginx/sites-available/vv-video-ai /etc/nginx/sites-enabled/`
    Testar configura√ß√£o: `sudo nginx -t`
    Recarregar NGINX: `sudo systemctl reload nginx`

*   **SSL/TLS com Let's Encrypt**:
    ```bash
    sudo apt install certbot python3-certbot-nginx
    sudo certbot --nginx -d your_domain.com -d www.your_domain.com
    ```
    Certbot ir√° modificar a configura√ß√£o do NGINX automaticamente.

### 2.3. Integra√ß√£o JWT (JSON Web Tokens)

JWTs ser√£o usados para autenticar e autorizar requisi√ß√µes para os servi√ßos protegidos.

*   **Fluxo de Autentica√ß√£o (Exemplo Simplificado para APIs/Servi√ßos):**
    1.  Um cliente/servi√ßo autenticado (e.g., um painel de administra√ß√£o, um script de gest√£o) solicita um token a um endpoint de autentica√ß√£o (que precisa ser criado). Este endpoint validaria credenciais (e.g., API key, usu√°rio/senha para um admin).
    2.  O endpoint de autentica√ß√£o gera um JWT assinado e o retorna ao cliente.
    3.  O cliente inclui o JWT no cabe√ßalho `Authorization` (e.g., `Authorization: Bearer <token>`) em requisi√ß√µes subsequentes aos servi√ßos protegidos.
    4.  NGINX ou o servi√ßo de backend valida o JWT.

*   **Gera√ß√£o e Valida√ß√£o de JWTs**:
    Pode ser feito em um servi√ßo Python (e.g., parte da sua FastAPI principal ou um novo microsservi√ßo de autentica√ß√£o).

    *   **Escolha da Biblioteca**: `PyJWT` para Python.
        ```bash
        pip install pyjwt cryptography
        ```
    *   **Gera√ß√£o de Chaves (Assim√©trica - RS256 recomendada):**
        ```bash
        # Chave Privada
        openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
        # Chave P√∫blica
        openssl rsa -pubout -in private_key.pem -out public_key.pem
        ```
        Armazene `private_key.pem` de forma segura no servi√ßo de autentica√ß√£o. `public_key.pem` pode ser usada pelo NGINX ou outros servi√ßos para valida√ß√£o.

    *   **Exemplo: Gera√ß√£o de Token (Python/FastAPI):**
        ```python
        import jwt
        import datetime

        # Carregar chave privada (idealmente de um local seguro)
        with open("private_key.pem", "rb") as key_file:
            private_key = key_file.read()

        def create_access_token(data: dict, expires_delta: datetime.timedelta = datetime.timedelta(minutes=15)):
            to_encode = data.copy()
            expire = datetime.datetime.utcnow() + expires_delta
            to_encode.update({"exp": expire, "iat": datetime.datetime.utcnow(), "iss": "VV-Video-AI-Auth"})
            # Adicionar 'aud' (audience) e 'sub' (subject) conforme necess√°rio
            encoded_jwt = jwt.encode(to_encode, private_key, algorithm="RS256")
            return encoded_jwt

        # Em um endpoint de login/auth:
        # user_api_key = "some_key_provided_by_user"
        # if verify_api_key(user_api_key): # Fun√ß√£o para verificar a API key
        #     token_data = {"sub": "service_account_for_tv_ui", "roles": ["viewer"]}
        #     access_token = create_access_token(data=token_data)
        #     return {"access_token": access_token, "token_type": "bearer"}
        ```

    *   **Valida√ß√£o de Token no NGINX (usando m√≥dulo `ngx_http_auth_jwt_module` ou similar):**
        Se estiver usando NGINX Plus ou um NGINX compilado com o m√≥dulo de autentica√ß√£o JWT:
        ```nginx
        location /tv_curado/ {
            auth_jwt "Protected Resource";
            auth_jwt_key_file /etc/nginx/public_key.pem; # Caminho para a chave p√∫blica
            # auth_jwt_leeway 30s; # Permite pequena varia√ß√£o de tempo
            # auth_jwt_alg RS256;

            proxy_pass http://localhost:8001/;
            # ...
        }
        ```
        Se n√£o, NGINX pode passar o token para o servi√ßo de backend para valida√ß√£o.

    *   **Valida√ß√£o de Token no Backend (Python/FastAPI Middleware):**
        ```python
        from fastapi import Request, HTTPException, Depends
        from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
        import jwt

        # Carregar chave p√∫blica
        with open("public_key.pem", "rb") as key_file:
            public_key = key_file.read()

        oauth2_scheme = HTTPBearer()

        async def get_current_user(token: HTTPAuthorizationCredentials = Depends(oauth2_scheme)):
            credentials_exception = HTTPException(
                status_code=401,
                detail="Could not validate credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
            try:
                payload = jwt.decode(token.credentials, public_key, algorithms=["RS256"], audience="VV-Video-AI-Service", issuer="VV-Video-AI-Auth")
                username: str = payload.get("sub")
                if username is None:
                    raise credentials_exception
                # Aqui voc√™ pode carregar o usu√°rio/entidade do banco de dados ou de outra fonte
                # e verificar pap√©is/permiss√µes se necess√°rio (e.g., payload.get("roles"))
            except jwt.ExpiredSignatureError:
                raise HTTPException(status_code=401, detail="Token has expired", headers={"WWW-Authenticate": "Bearer"})
            except jwt.InvalidTokenError:
                raise credentials_exception
            return {"username": username, "roles": payload.get("roles", [])}

        # Em um endpoint protegido:
        # @app.get("/status", dependencies=[Depends(get_current_user)])
        # async def read_status(current_user: dict = Depends(get_current_user)):
        #     if "admin" not in current_user.get("roles", []):
        #          raise HTTPException(status_code=403, detail="Not enough permissions")
        #     return {"status": "ok", "user": current_user}
        ```

*   **Claims do JWT**:
    *   `iss` (Issuer): Quem emitiu o token (e.g., `VV-Video-AI-Auth`).
    *   `sub` (Subject): O principal que √© o sujeito do token (e.g., ID do usu√°rio, nome do servi√ßo).
    *   `aud` (Audience): Destinat√°rio(s) que o JWT se destina (e.g., `VV-Video-AI-Service`).
    *   `exp` (Expiration Time): Timestamp de quando o token expira.
    *   `iat` (Issued At): Timestamp de quando o token foi emitido.
    *   `nbf` (Not Before): Timestamp de quando o token se torna v√°lido.
    *   Claims customizados (e.g., `roles`, `permissions`).

*   **Armazenamento de Token no Cliente**:
    *   Para UIs (como `tv.html` se precisar de login): `HttpOnly` cookies s√£o geralmente mais seguros contra XSS do que `localStorage`.
    *   Para chamadas de API server-to-server ou script: O cliente armazena o token na mem√≥ria e o inclui em cada requisi√ß√£o.

### 2.4. Gerenciamento Seguro de Chaves

*   **Chaves Privadas (JWT, SSL)**:
    *   Devem ser armazenadas de forma extremamente segura.
    *   Acesso restrito ao m√≠nimo de processos/usu√°rios necess√°rios.
    *   Considere usar Docker Secrets, HashiCorp Vault, ou vari√°veis de ambiente injetadas por um sistema de CI/CD seguro para chaves JWT.
    *   N√£o comitar chaves privadas no reposit√≥rio Git.
*   **Rota√ß√£o de Chaves**: Implementar uma pol√≠tica para rota√ß√£o peri√≥dica das chaves JWT.

## 3. Walkthrough: Protegendo o Endpoint `/status`

1.  **Gerar Chaves RS256**: `private_key.pem` e `public_key.pem`.
2.  **Criar um Servi√ßo de Autentica√ß√£o (simplificado)**:
    *   Adicionar um endpoint (e.g., `/auth/token`) na sua aplica√ß√£o FastAPI principal.
    *   Este endpoint recebe uma API key (predefinida ou de um `.env` por agora).
    *   Se a API key for v√°lida, gera um JWT usando `private_key.pem` com `sub: "admin_user"`, `roles: ["admin"]`, `aud: "VV-Video-AI-Service"`.
3.  **Modificar o Endpoint `/status`**:
    *   Adicionar o `Depends(get_current_user)` para validar o token JWT usando `public_key.pem`.
    *   Verificar se o usu√°rio tem o papel "admin".
4.  **Configurar NGINX**:
    *   Garantir que NGINX est√° fazendo proxy para o servi√ßo FastAPI.
    *   Se NGINX n√£o estiver validando o JWT, ele simplesmente passar√° o cabe√ßalho `Authorization` para o backend.
5.  **Testar**:
    *   Tentar acessar `/status` sem token (deve falhar com 401).
    *   Chamar `/auth/token` com a API key correta para obter um JWT.
    *   Chamar `/status` com o JWT no cabe√ßalho `Authorization: Bearer <token>` (deve ter sucesso).
    *   Tentar com um token expirado ou inv√°lido (deve falhar).

## 4. Impacto Esperado

*   Aumento significativo da seguran√ßa da aplica√ß√£o.
*   Controle de acesso granular aos servi√ßos e APIs.
*   Preven√ß√£o de acesso n√£o autorizado a dados sens√≠veis ou funcionalidades cr√≠ticas.

---
**Pr√≥ximo Passo**: Revisar e discutir este plano detalhado. Em seguida, podemos passar para o item 12.2.