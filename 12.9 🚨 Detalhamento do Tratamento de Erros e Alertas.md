Understood! We'll aim for a comprehensive expansion of `12.9 üö® Detalhamento do Tratamento de Erros e Alertas`.

Here's a more detailed version:

---

## 12.9 üö® Detalhamento do Tratamento de Erros, Alertas e Notifica√ß√µes

**Objetivo:** Desenvolver um sistema de tratamento de erros, alertas e notifica√ß√µes abrangente, granular e acion√°vel, que melhore a detec√ß√£o proativa de problemas, acelere o diagn√≥stico e a resolu√ß√£o, e aumente a resili√™ncia geral do `VV-Video-AI-System`.

**Contexto:** O sistema j√° possui `self_monitor.py` para rein√≠cio de containers e a inten√ß√£o de usar webhooks (Slack/Telegram). Esta se√ß√£o expande essa base.

---

### 1. Arquitetura de Alertas e Notifica√ß√µes

*   **Componente Central de Alertas (Proposto):** Um m√≥dulo `vv-core/alerter.py` (ou um pequeno servi√ßo/script dedicado) que:
    *   Fornece uma fun√ß√£o unificada para enviar alertas (e.g., `send_alert(level, title, message_details, source_component)`).
    *   Gerencia a formata√ß√£o das mensagens para diferentes canais.
    *   Lida com a l√≥gica de envio para os webhooks configurados (Slack, Telegram, etc.).
    *   Pode implementar throttling/deduplica√ß√£o b√°sica se necess√°rio.
    *   L√™ a configura√ß√£o dos endpoints de webhook de vari√°veis de ambiente ou de um arquivo de configura√ß√£o seguro.
*   **Integra√ß√£o com Logging:** Alertas cr√≠ticos tamb√©m devem ser logados com destaque em `logs/app.log`.
*   **N√≠veis de Severidade:**
    *   `INFO`: Eventos operacionais normais, mas not√°veis (e.g., in√≠cio/fim de um batch de processamento). (Opcional para alertas, mais para logs)
    *   `WARNING`: Condi√ß√µes anormais que n√£o impedem o funcionamento, mas podem indicar problemas futuros ou degrada√ß√£o (e.g., espa√ßo em disco chegando a 80%, um v√≠deo demorando mais que o usual).
    *   `ERROR`: Falhas que afetam uma funcionalidade espec√≠fica ou o processamento de um item (e.g., falha no processamento de um v√≠deo, falha na valida√ß√£o de schema).
    *   `CRITICAL`: Falhas que afetam a funcionalidade principal do sistema ou indicam uma interrup√ß√£o grave (e.g., falha persistente de um container essencial, incapacidade de acessar `VIDEO_STORAGE_ROOT`).

---

### 2. Gatilhos de Alerta Espec√≠ficos e Detalhamento

#### 2.1. Falhas de Container e Servi√ßo

*   **Gatilho:** Falha persistente de um container espec√≠fico (ap√≥s `N` rein√≠cios por `self_monitor.py`).
    *   **`N` tentativas:** Configur√°vel (e.g., `SELF_MONITOR_MAX_RESTARTS = 5` via vari√°vel de ambiente).
    *   **Detec√ß√£o:** `self_monitor.py` rastreia contagens de rein√≠cio. Ao atingir `N`, ele envia um alerta `CRITICAL`.
    *   **A√ß√£o Imediata (Al√©m do Alerta):** `self_monitor.py` pode parar de tentar reiniciar o container problem√°tico para evitar loops de falha e consumo excessivo de recursos, dependendo da pol√≠tica.
*   **Falha de Healthcheck:**
    *   **Gatilho:** Um container falha em seu healthcheck repetidamente.
    *   **Detec√ß√£o:** Docker (via `docker-compose` healthcheck status) ou `self_monitor.py` verificando `docker ps --filter health=unhealthy`.
    *   **Alerta:** `ERROR` ou `CRITICAL` dependendo da import√¢ncia do container.

#### 2.2. Erros de Processamento de Dados e Valida√ß√£o

*   **Erro de Valida√ß√£o de Schema:**
    *   **Gatilho:** Falha na valida√ß√£o de um JSON gerado contra seu schema (`analytic.schema.json`, `summary.schema.json`, `logline.schema.json`).
    *   **Detec√ß√£o:** Dentro dos scripts Python (`scan_video.py`, `summarize_scene.py`, `logline_generator.py`) usando `vv-core/utils.py validate_schema()`.
    *   **Alerta:** `ERROR`.
    *   **A√ß√£o Imediata:** Logar o erro detalhado, o dado inv√°lido (ou um trecho), e o schema. Opcionalmente, mover o arquivo de origem ou o JSON problem√°tico para `corrupted/` com metadados do erro.
*   **Falha na Assinatura/Verifica√ß√£o HMAC:**
    *   **Gatilho:** `sign_payload()` ou `verify_signature()` em `vv-core/utils.py` falha.
    *   **Detec√ß√£o:** No `logline_generator.py` (ao assinar) ou `logline_verifier.py` (ao verificar).
    *   **Alerta:** `CRITICAL` (indica potencial problema de seguran√ßa ou corrup√ß√£o de dados/chave).
    *   **A√ß√£o Imediata:** Logar o incidente detalhadamente. A verifica√ß√£o falha pode impedir o uso da LogLine.

#### 2.3. Problemas de Recursos do Sistema

*   **Espa√ßo em Disco Cr√≠tico:**
    *   **Gatilho:** Espa√ßo livre em `${VIDEO_STORAGE_ROOT}` ou no disco do sistema operacional abaixo de um limiar cr√≠tico.
    *   **Detec√ß√£o:** Um script de monitoramento (pode ser parte do `self_monitor.py` ou um cronjob separado) que verifica `df -h`.
        *   Limiar de `WARNING`: e.g., < 20% livre ou < 50GB livres.
        *   Limiar de `ERROR`/`CRITICAL`: e.g., < 10% livre ou < 10GB livres.
    *   **Alerta:** `WARNING` ou `CRITICAL`.
    *   **A√ß√£o Imediata:** Para `CRITICAL`, pode ser necess√°rio pausar a ingest√£o de novos v√≠deos se poss√≠vel.
*   **Uso Elevado de CPU/Mem√≥ria Persistente:**
    *   **Gatilho:** Um container ou o sistema como um todo excede limiares de CPU/Mem√≥ria por um per√≠odo prolongado.
    *   **Detec√ß√£o:** Via `docker stats` ou integra√ß√£o com Prometheus/cAdvisor.
    *   **Alerta:** `WARNING`.
    *   **Contexto:** O Self-Monitor LLM (`12.2`) poderia analisar isso mais profundamente.

#### 2.4. Performance e Conectividade

*   **Processamento de V√≠deo Excedendo Tempo M√°ximo Esperado:**
    *   **Gatilho:** Uma etapa do pipeline (`scan_video`, `summarize_scene`) demora significativamente mais que a m√©dia ou um teto definido.
    *   **Detec√ß√£o:** Os scripts podem registrar tempos de in√≠cio/fim. O `orchestrator.py` ou um monitor pode verificar esses tempos.
        *   Definir `MAX_PROCESSING_TIME_SCAN_VIDEO`, `MAX_PROCESSING_TIME_SUMMARIZE` (e.g., baseado no tamanho do v√≠deo ou dura√ß√£o).
    *   **Alerta:** `WARNING`.
    *   **A√ß√£o Imediata:** Logar o v√≠deo e o tempo. Considerar se o v√≠deo deve ser movido para `corrupted/` ou marcado para inspe√ß√£o.
*   **Falhas de Conex√£o com `DVR_IP` (em `agent_dvr`):**
    *   **Gatilho:** Incapacidade de conectar ao DVR, receber stream, ou erros de autentica√ß√£o.
    *   **Detec√ß√£o:** Dentro do c√≥digo do `agent_dvr`.
    *   **Alerta:** `ERROR` ap√≥s algumas tentativas falhas; `CRITICAL` se persistir por um tempo definido (e.g., 15 minutos).
    *   **A√ß√£o Imediata:** `agent_dvr` deve ter l√≥gica de retry com backoff exponencial.

#### 2.5. Erros de Scripts e Orquestra√ß√£o

*   **Falha Inesperada em Scripts Python:**
    *   **Gatilho:** Exce√ß√£o n√£o capturada ou erro gen√©rico em qualquer script principal.
    *   **Detec√ß√£o:** Blocos `try-except Exception as e` de √∫ltimo recurso.
    *   **Alerta:** `ERROR`.
*   **Falha do `orchestrator.py` em processar um v√≠deo ap√≥s N tentativas:**
    *   **Gatilho:** O orquestrador tenta processar um v√≠deo espec√≠fico m√∫ltiplas vezes, mas uma das etapas (`scan_video`, `summarize_scene`, `logline_generator`) falha consistentemente para esse v√≠deo.
    *   **Detec√ß√£o:** O `orchestrator.py` precisa manter um contador de tentativas por v√≠deo.
    *   **Alerta:** `ERROR`.
    *   **A√ß√£o Imediata:** Mover o v√≠deo problem√°tico para `corrupted/` com um arquivo de log detalhando as falhas.
*   **Falha na Execu√ß√£o de Cronjobs:**
    *   **Gatilho:** Um cronjob (`orchestrator.py`, `cleanup_old_files.py`, `log_exporter.py`) n√£o √© executado ou falha.
    *   **Detec√ß√£o:**
        *   Usar uma ferramenta como `cronic` (wrapper para cronjobs que s√≥ envia email/output em caso de falha).
        *   Scripts podem "tocar" um arquivo de "heartbeat" ao concluir com sucesso; um monitor verifica o timestamp desse arquivo.
    *   **Alerta:** `ERROR`.

---

### 3. Alertas Acion√°veis: Conte√∫do e Formato

Cada alerta deve fornecer informa√ß√µes suficientes para uma a√ß√£o r√°pida.

*   **Campos Padr√£o para Alertas:**
    *   `Timestamp (UTC)`: Quando o alerta foi gerado.
    *   `Severity`: `WARNING`, `ERROR`, `CRITICAL`.
    *   `SourceComponent`: Nome do container, script ou subsistema (e.g., `scene_scanner`, `orchestrator.py`, `DiskMonitor`).
    *   `Hostname/DeviceID`: Identificador do edge device onde ocorreu o problema.
    *   `Title`: Um resumo conciso do problema (e.g., "Scene Scanner Container Failed Persistently").
    *   `MessageDetails`:
        *   Descri√ß√£o detalhada do erro.
        *   Contexto relevante (e.g., nome do arquivo de v√≠deo, ID do v√≠deo, hash).
        *   Trechos de log de erro (se aplic√°vel e conciso).
        *   Valores espec√≠ficos (e.g., "Disk space at 95% full on /opt/vv-video-ai-system/storage").
    *   `SuggestedActions` (Opcional): Breves sugest√µes de pr√≥ximos passos (e.g., "Check container logs", "Verify DVR connectivity").
    *   `AlertID` (Opcional): Um ID √∫nico para rastreamento.

*   **Exemplo de Mensagem (JSON para Slack/Webhook):**
    ```json
    {
      "timestamp": "2025-05-15T10:30:00Z",
      "severity": "CRITICAL",
      "source_component": "self_monitor.py",
      "hostname": "edge-device-001",
      "title": "Container 'scene_scanner' Failed Persistently",
      "message_details": "Container 'scene_scanner' has failed to start or stay healthy after 5 restart attempts. Last error log snippet: [OSError: Disk full]. Service may be degraded.",
      "suggested_actions": "1. Check disk space on edge-device-001. 2. Manually inspect 'scene_scanner' logs: `docker logs scene_scanner`. 3. Consider running cleanup script.",
      "video_file_context": "N/A"
    }
    ```

---

### 4. Tratamento Robusto de Falhas em Scripts Python

*   **Blocos `try-except` Espec√≠ficos e Gen√©ricos:**
    ```python
    # Em scan_video.py, summarize_scene.py, etc.
    # from vv_core.alerter import send_alert # Exemplo

    video_path = "path/to/video.mp4"
    try:
        # ... l√≥gica principal do script ...
        if not validate_schema(data, schema_path): # Exemplo de valida√ß√£o
            error_details = {"video": str(video_path), "reason": "Schema validation failed", "data_snippet": str(data)[:200]}
            # send_alert("ERROR", "Schema Validation Failed", error_details, "scan_video.py")
            logging.error(f"Schema validation failed for {video_path}. Details: {error_details}")
            move_to_corrupted(video_path, "schema_validation_error", error_details)
            return False # ou raise uma exce√ß√£o customizada
        
        # ... mais l√≥gica ...

    except FileNotFoundError as fnf_error:
        error_details = {"video": str(video_path), "error": str(fnf_error)}
        # send_alert("ERROR", "File Not Found During Processing", error_details, "scan_video.py")
        logging.error(f"File not found error for {video_path}: {fnf_error}")
        # N√£o mover para corrupted se o arquivo de entrada n√£o foi encontrado, a menos que seja esperado.
        return False
    except CustomProcessingError as cpe_error: # Exce√ß√£o customizada da l√≥gica de neg√≥cio
        error_details = {"video": str(video_path), "error_type": type(cpe_error).__name__, "message": str(cpe_error)}
        # send_alert("ERROR", "Video Processing Error", error_details, "scan_video.py")
        logging.error(f"Custom processing error for {video_path}: {cpe_error}")
        move_to_corrupted(video_path, type(cpe_error).__name__, error_details)
        return False
    except Exception as e: # Captura gen√©rica de √∫ltimo recurso
        error_details = {"video": str(video_path), "error_type": type(e).__name__, "message": str(e), "traceback": traceback.format_exc()}
        # send_alert("CRITICAL", "Unhandled Exception in Processing", error_details, "scan_video.py")
        logging.critical(f"Unhandled exception processing {video_path}: {e}", exc_info=True)
        move_to_corrupted(video_path, "unhandled_exception", error_details)
        return False # Sinaliza falha ao orquestrador
    ```

*   **Movimenta√ß√£o para `corrupted/`:**
    *   Ao mover um arquivo para `corrupted/`, criar um arquivo `.meta.json` correspondente.
        *   Ex: `video_problematic.mp4` -> `corrupted/video_problematic.mp4` e `corrupted/video_problematic.mp4.meta.json`
    *   Conte√∫do do `.meta.json`:
        ```json
        {
          "original_path": "input/video_problematic.mp4",
          "timestamp_corruption": "2025-05-15T10:35:00Z",
          "source_component": "scan_video.py",
          "error_type": "SchemaValidationError", // ou "UnhandledException", "MaxProcessingTimeExceeded"
          "error_message": "Schema validation failed for field 'xyz'.",
          "log_snippet_ref": "app.log around 2025-05-15T10:35:00Z for more details",
          "original_hash_sha256": "abcdef123..." // (Opcional, se calculado antes da falha)
        }
        ```
*   **L√≥gica de Retry Interna:** Alguns erros (e.g., falhas de rede transit√≥rias, locks de arquivos) podem se beneficiar de algumas tentativas de retry com backoff dentro do pr√≥prio script antes de desistir e marcar como falha.

---

### 5. Canais de Alerta e Ferramentas

*   **Prim√°rio:**
    *   **Slack/Telegram Webhooks:** Para notifica√ß√µes em tempo real para a equipe operacional.
        *   Configura√ß√£o: URLs de webhook armazenadas como vari√°veis de ambiente (e.g., `SLACK_WEBHOOK_URL`, `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID`).
*   **Secund√°rio/Opcional:**
    *   **Email:** Para resumos di√°rios ou alertas menos urgentes. Requer configura√ß√£o de um servidor SMTP ou servi√ßo de email.
    *   **Prometheus Alertmanager:** Se o sistema de m√©tricas (`12.10`) estiver totalmente implementado, o Alertmanager pode se tornar o principal manipulador de alertas, lidando com roteamento, agrupamento, silenciamento e escalonamento para v√°rios canais (incluindo Slack, PagerDuty, etc.). Os scripts Python poderiam expor m√©tricas que o Alertmanager observa, ou um "pusher" de alertas poderia enviar eventos para o Alertmanager.
    *   **PagerDuty/Opsgenie:** Para incidentes cr√≠ticos que requerem resposta imediata, integrados via webhook ou Alertmanager.

---

### 6. Throttling e Deduplica√ß√£o de Alertas

*   **Objetivo:** Evitar "alert fatigue" causada por problemas recorrentes gerando muitos alertas id√™nticos.
*   **Estrat√©gias:**
    1.  **No Componente Central de Alertas:**
        *   Manter um cache em mem√≥ria dos √∫ltimos N alertas ou alertas recentes dentro de uma janela de tempo.
        *   Se um alerta id√™ntico (mesma `SourceComponent`, `Title`, e talvez uma chave de contexto) for disparado novamente em X minutos, ele pode ser suprimido ou um contador pode ser incrementado em um alerta de resumo.
    2.  **No Alertmanager (se usado):** O Alertmanager tem funcionalidades robustas de agrupamento e inibi√ß√£o.
    3.  **Nos pr√≥prios scripts (para erros muito repetitivos):** Por exemplo, se a conex√£o com o DVR falhar, alertar na primeira falha e depois apenas a cada 15-30 minutos se o problema persistir, em vez de a cada tentativa de reconex√£o.

---

### 7. Impacto Esperado

*   **Resolu√ß√£o de Problemas Mais R√°pida:** Alertas acion√°veis com contexto levam a diagn√≥sticos mais r√°pidos.
*   **Melhor Entendimento da Sa√∫de do Sistema:** Visibilidade granular sobre o estado de diferentes componentes.
*   **Maior Resili√™ncia:** Tratamento de erro aprimorado previne que falhas em um item impactem todo o sistema; arquivos problem√°ticos s√£o isolados.
*   **Opera√ß√£o Proativa:** Alertas de `WARNING` (e.g., disco baixo) permitem interven√ß√£o antes que se tornem `CRITICAL`.
*   **Redu√ß√£o do Esfor√ßo Manual:** Menos necessidade de vasculhar logs manualmente para encontrar a causa raiz de problemas.

---

This detailed plan for `12.9` should provide a solid roadmap for enhancing the error handling and alerting capabilities of the VV-Video-AI-System.
